Acerca do Design Geral, foram criados dois Controladores, um para Animais e outro para ZooKeepers, tal decisão foi tomada para melhor coesão e manipulação de tais entidades, seguindo o Padrão GRASP, assim sendo deixando definida as responsabilidades, o Controller de Animais armazena e cuida de todas as operações com Animais, do mesmo modo o Controller de Zoo Keepers Armazena e cuida de todas as operações com Zoo Keepers, uma camada acima está o ZooManagement, classe de Sistema que instancia os dois controladores, em tal classe é possível implementar logicas que utilizem os dois controladores sem que um controlador necessite conhecer ao outro, de tal modo o acoplamento de classes é reduzido, e ainda possibilita que a facade também só precise conhecer o ZooManagement ratificando a redução de acoplamento.

Para a Entidade Animal, foi criada uma interface AnimalInterface com o propósito de garantir o cumprimento do contrato do comportamento da Entidade Animal, assim em tal interface são definidas as assinaturas dos métodos que devem ser cumpridas em Animal, para valores constantes foram utilizadas constantes do tipo ENUM com intuito de explorar o benefício polimórfico do polimorfismo de tipos, foi ainda utilizado o Polimorfismo de sobrecarga na assinatura dos construtores da classe Animal e métodos dos controladores, que tratam a disponibilidade ou não de parâmetros.

As entidades Medication e Vaccine foram criadas para encapsular melhor as suas referidas informações, sendo assim é utilizada uma composição de tais entidades na classe Animal, do mesmo modo foi criada a Entidade Offspring, sendo que esta possuí um método auxiliar indicando a presença ou não de seus atributos.

Sobre o uso das Java Collections, as decisões de uso se basearam no critério da necessidade de cada entidade, para os Controladores e ZooKeepers foram utilizados Mapas, que permitem o melhor gerenciamento de Animais e ZooKeepers através de chaves únicas, visto que esses possuem operações de busca por chave em diversos métodos e adoção de tal coleção torna os respectivos métodos mais eficientes,  para Entidades que não possuem repetição contudo não necessitam de busca por chave, apenas para fim de armazenamento, foram utilizados SETS devido a mecanismo que impede a inserção de valores repetidos, o uso eficiente do contains e do remove de tal.

Os tipos das Collections empregadas foram declarados a partir de suas interfaces, com fim de tornar a manutenção do código mais fácil e diminuir o acoplamento de suas implementações, foram ainda utilizadas as classes Auxiliar e Utils, para armazenamento da quebra de linha utilizada constantemente e validação de parâmetros, possibilitando o reuso de código, foram criadas ainda Exceções personalizadas que permitem o devido tratamento de situações que fogem do padrão do programa, por fim o uso de Packages que permitem a devida organização das classes, divididas com base em suas categorias.
